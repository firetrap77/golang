package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "net/url"
    "time"
    "bufio"
    "os"
    "os/exec"
    "strconv"
    "strings"
)

type AutoGenerated struct {
    Batchcomplete string `json:"batchcomplete"`
    Continue      struct {
        Sroffset int    `json:"sroffset"`
        Continue string `json:"continue"`
    } `json:"continue"`
    Query struct {
        Searchinfo struct {
            Totalhits int `json:"totalhits"`
        } `json:"searchinfo"`
        Search []struct {
            Ns        int       `json:"ns"`
            Title     string    `json:"title"`
            Pageid    int       `json:"pageid"`
            Size      int       `json:"size"`
            Wordcount int       `json:"wordcount"`
            Snippet   string    `json:"snippet"`
            Timestamp time.Time `json:"timestamp"`
        } `json:"search"`
    } `json:"query"`
}

func openPage(selection string, record AutoGenerated) {

clean_selection := strings.TrimSuffix(selection, "\n")
index,err := strconv.Atoi(clean_selection)
  if err != nil {
        log.Fatal("Parsing selection string to int: ", err)
        //return err
    }
title := record.Query.Search[index].Title
clean_title := strings.Replace(title, " ", "_", -1)
main_command := "https://en.wikipedia.org/wiki/%s"
full_command := fmt.Sprintf(main_command, clean_title)
out,err := exec.Command("/usr/bin/open", full_command).Output()
    if err != nil {

        log.Fatal(err)

    }
fmt.Printf("Output of cmd is %s\n", out)
}

func readInput() string {
reader := bufio.NewReader(os.Stdin)
// Prompt and read
fmt.Print("Enter text: ")
text, _ := reader.ReadString('\n')
return text
}

func makeSearch(query string) (error, AutoGenerated) {
    // QueryEscape escapes the phone string so
    // it can be safely placed inside a URL query
    safeQuery := url.QueryEscape(query)

    url := fmt.Sprintf("https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=%s&format=json", safeQuery)

    // Build the request
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        log.Fatal("NewRequest: ", err)
        //return err
    }

    // For control over HTTP client headers,
    // redirect policy, and other settings,
    // create a Client
    // A Client is an HTTP client
    client := &http.Client{}

    // Send the request via a client
    // Do sends an HTTP request and
    // returns an HTTP response
    resp, err := client.Do(req)
    if err != nil {
        log.Fatal("Do: ", err)
        //return err
    }

    // Callers should close resp.Body
    // when done reading from it
    // Defer the closing of the body
    defer resp.Body.Close()

    // Fill the record with the data from the JSON
    var record  AutoGenerated

    // Use json.Decode for reading streams of JSON data
    if err := json.NewDecoder(resp.Body).Decode(&record); err != nil {
        log.Println(err)
    }
   for i, value := range record.Query.Search {
    fmt.Println("Title  = ", i, value.Title)
   }
  return err, record
}

func postToSlack() {


}

func main() {
query := readInput()
err, record := makeSearch(query)
  if err != nil {
        log.Fatal("makeSearch: ", err)
        //return err
    }
selection := readInput()
openPage(selection, record)

}
